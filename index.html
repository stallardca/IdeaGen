<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Interactive Business Idea Mind Map</title>
  <!-- Load D3.js -->
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    h1 {
      text-align: center;
    }
    #controls {
      text-align: center;
      margin-bottom: 20px;
    }
    .node circle {
      fill: #fff;
      stroke: steelblue;
      stroke-width: 3px;
    }
    .node text {
      font: 12px sans-serif;
      pointer-events: none;
    }
    .link {
      fill: none;
      stroke: #ccc;
      stroke-width: 2px;
    }
  </style>
</head>
<body>
  <h1>Interactive Business Idea Mind Map</h1>
  <div id="controls">
    <label for="interests">Enter your interests (comma separated): </label>
    <input type="text" id="interests" placeholder="e.g. tech, art, sustainability">
    <button id="generate">Generate Ideas</button>
  </div>
  <svg width="960" height="600"></svg>

  <script>
    // Global variables and initial data
    let selectedNodes = []; // Stores ideas the user selects
    let i = 0; // Used for node IDs

    // The root node of our mind map
    let rootData = {
      name: "Business Ideas",
      children: []  // Initially empty; populated via user input
    };

    // Set up the SVG canvas and group for our mind map
    const svg = d3.select("svg"),
          width = +svg.attr("width"),
          height = +svg.attr("height");

    const g = svg.append("g").attr("transform", "translate(40,0)");

    // Create a tree layout generator
    const tree = d3.tree().size([height, width - 160]);

    // Convert our data to a hierarchy
    let root = d3.hierarchy(rootData, d => d.children);

    // Function to generate random ideas based on interests or parent node name
    function generateIdeas(baseText) {
      // Split the base text (could be multiple interests) into an array
      let topics = baseText.split(/,|\s+/).filter(s => s.length > 0);
      if (topics.length === 0) {
        topics = ["Innovative", "Creative", "Sustainable"];
      }
      let ideas = [];
      topics.forEach(topic => {
        ideas.push({ name: topic + " Innovator", children: [] });
        ideas.push({ name: "Smart " + topic + " Solutions", children: [] });
        ideas.push({ name: topic + " 2.0", children: [] });
      });
      return ideas;
    }

    // Update function to (re)draw the mind map
    function update(source) {
      // Recompute the tree layout.
      root = d3.hierarchy(rootData, d => d.children);
      const treeData = tree(root);

      // Get nodes and links
      const nodes = treeData.descendants(),
            links = treeData.descendants().slice(1);

      // Normalize for fixed-depth.
      nodes.forEach(d => { d.y = d.depth * 180; });

      // Nodes section
      const node = g.selectAll("g.node")
                    .data(nodes, d => d.id || (d.id = ++i));

      const nodeEnter = node.enter().append("g")
                          .attr("class", "node")
                          .attr("transform", d => `translate(${d.y},${d.x})`)
                          .on("click", function(event, d) {
                            // When clicking on a node, expand it if not already expanded
                            if (!d.data.children || d.data.children.length === 0) {
                              d.data.children = generateIdeas(d.data.name);
                            }
                            // Store the selected idea if not already stored
                            if (!selectedNodes.includes(d.data.name)) {
                              selectedNodes.push(d.data.name);
                              console.log("Selected Ideas:", selectedNodes);
                            }
                            update(d);
                          });

      nodeEnter.append("circle")
               .attr("r", 10);

      nodeEnter.append("text")
               .attr("dy", 3)
               .attr("x", d => d.children ? -12 : 12)
               .style("text-anchor", d => d.children ? "end" : "start")
               .text(d => d.data.name);

      // Merge nodes for update and apply transition
      const nodeUpdate = nodeEnter.merge(node);
      nodeUpdate.transition()
                .duration(200)
                .attr("transform", d => `translate(${d.y},${d.x})`);

      // Remove exiting nodes
      const nodeExit = node.exit().transition()
                          .duration(200)
                          .attr("transform", d => `translate(${source.y},${source.x})`)
                          .remove();

      // Links section
      const link = g.selectAll("path.link")
                    .data(links, d => d.id);

      const linkEnter = link.enter().insert("path", "g")
                          .attr("class", "link")
                          .attr("d", d => {
                            let o = { x: source.x, y: source.y };
                            return diagonal(o, o);
                          });

      // Merge links and update positions
      const linkUpdate = linkEnter.merge(link);
      linkUpdate.transition()
                .duration(200)
                .attr("d", d => diagonal(d, d.parent));

      // Remove exiting links
      const linkExit = link.exit().transition()
                          .duration(200)
                          .attr("d", d => {
                            let o = { x: source.x, y: source.y };
                            return diagonal(o, o);
                          })
                          .remove();
    }

    // Helper function to create a curved (diagonal) path from parent to child nodes
    function diagonal(s, d) {
      return `M ${s.y} ${s.x}
              C ${(s.y + d.y) / 2} ${s.x},
                ${(s.y + d.y) / 2} ${d.x},
                ${d.y} ${d.x}`;
    }

    // Initial render of the mind map
    update(rootData);

    // Event listener for generating initial ideas based on user input
    document.getElementById("generate").addEventListener("click", function() {
      const interests = document.getElementById("interests").value;
      // Generate ideas and set as children of the root
      rootData.children = generateIdeas(interests);
      update(rootData);
    });
  </script>
</body>
</html>
